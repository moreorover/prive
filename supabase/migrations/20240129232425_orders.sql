create extension if not exists "uuid-ossp";

create table public.hair (
  id            integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  upc           text not null default '',
  title         text not null default '',
  description   text not null default '',
  length        integer not null default 0,
  weight_purchased        integer not null,
  weight_in_stock        integer not null,
  purchase_price numeric(10,2) not null default 0,
  deleted       boolean not null default false,
  created_by    uuid references public.profiles not null,
  updated_by    uuid references public.profiles,
  deleted_by    uuid references public.profiles,
  created_at    timestamp with time zone default now() not null,
  updated_at    timestamp with time zone default null,
  deleted_at    timestamp with time zone default null
);
comment on table public.hair is 'Table to hold records on hair stock.';

-- Row-Level Security and Policies for Profiles
alter table public.hair enable row level security;

-- Policy for SELECT
create policy "Admins can view all hair" on public.hair
for select
using (
    authorize('Admin', auth.uid())
);

-- Policy for INSERT
create policy "Only Admins can create hair" on public.hair
for insert
with check (
    authorize('Admin', auth.uid())
);

-- Policy for UPDATE
create policy "Only Admins can update hair" on public.hair
for update
using (
    authorize('Admin', auth.uid())
);

create table public.products (
  id                uuid not null default uuid_generate_v4(),
  upc               text not null default '',
  title             text not null,
  description       text not null default '',
  supplier_id       uuid references public.clients,
  purchase_price    numeric(10,2) not null default 0,
  rrp               numeric(10,2) not null default 0,
  units_in_stock    integer not null default 0,
  created_by        uuid references public.profiles not null,
  updated_by        uuid references public.profiles,
  deleted_by        uuid references public.profiles,
  created_at        timestamp with time zone default now() not null,
  updated_at        timestamp with time zone default null,
  deleted_at        timestamp with time zone default null,
  primary key (id)
);
comment on table public.products is 'Table to hold records on products stock.';

-- Row-Level Security and Policies for Profiles
alter table public.products enable row level security;

-- Policy for SELECT
create policy "Admins can view all products" on public.products
for select
using (
    authorize('Admin', auth.uid())
);

-- Policy for INSERT
create policy "Only Admins can create products" on public.products
for insert
with check (
    authorize('Admin', auth.uid())
);

-- Policy for UPDATE
create policy "Only Admins can update products" on public.products
for update
using (
    authorize('Admin', auth.uid())
);

CREATE TYPE order_type AS ENUM ('purchase', 'sale');
CREATE TYPE order_status AS ENUM ('pending', 'completed', 'cancelled');


create table public.orders (
  id                uuid not null default uuid_generate_v4(),
  client_id         uuid references public.clients,
  ordered_at        timestamp with time zone default now() not null,
  order_type        order_type not null,
  order_status      order_status not null,
  created_by        uuid references public.profiles not null,
  updated_by        uuid references public.profiles,
  deleted_by        uuid references public.profiles,
  created_at        timestamp with time zone default now() not null,
  updated_at        timestamp with time zone default null,
  deleted_at        timestamp with time zone default null,
  primary key (id)
);
comment on table public.orders is 'Table to hold records on orders stock.';

-- Row-Level Security and Policies for Profiles
alter table public.orders enable row level security;

-- Policy for SELECT
create policy "Admins can view all orders" on public.orders
for select
using (
    authorize('Admin', auth.uid())
);

-- Policy for INSERT
create policy "Only Admins can create orders" on public.orders
for insert
with check (
    authorize('Admin', auth.uid())
);

-- Policy for UPDATE
create policy "Only Admins can update orders" on public.orders
for update
using (
    authorize('Admin', auth.uid())
);

create table public.order_products (
  id                uuid not null default uuid_generate_v4(),
  client_id         uuid references public.clients,
  order_id          uuid references public.orders,
  product_id        uuid references public.products,
  quantity          integer default 0,
  unit_price        numeric(10, 2) default 0,
  created_by        uuid references public.profiles not null,
  updated_by        uuid references public.profiles,
  deleted_by        uuid references public.profiles,
  created_at        timestamp with time zone default now() not null,
  updated_at        timestamp with time zone default null,
  deleted_at        timestamp with time zone default null,
  primary key (id)
);
comment on table public.order_products is 'Table to hold records on order_products stock.';

-- Row-Level Security and Policies for Profiles
alter table public.order_products enable row level security;

-- Policy for SELECT
create policy "Admins can view all order_products" on public.order_products
for select
using (
    authorize('Admin', auth.uid())
);

-- Policy for INSERT
create policy "Only Admins can create order_products" on public.order_products
for insert
with check (
    authorize('Admin', auth.uid())
);

-- Policy for UPDATE
create policy "Only Admins can update order_products" on public.order_products
for update
using (
    authorize('Admin', auth.uid())
);

create table public.order_hair (
  id                uuid not null default uuid_generate_v4(),
  client_id         uuid references public.clients,
  order_id          uuid references public.orders,
  hair_id        integer references public.hair,
  weight          integer default 0,
  price        numeric(10, 2) default 0,
  created_by        uuid references public.profiles not null,
  updated_by        uuid references public.profiles,
  deleted_by        uuid references public.profiles,
  created_at        timestamp with time zone default now() not null,
  updated_at        timestamp with time zone default null,
  deleted_at        timestamp with time zone default null,
  primary key (id)
);
comment on table public.order_hair is 'Table to hold records on order_hair stock.';

-- Row-Level Security and Policies for Profiles
alter table public.order_hair enable row level security;

-- Policy for SELECT
create policy "Admins can view all order_hair" on public.order_hair
for select
using (
    authorize('Admin', auth.uid())
);

-- Policy for INSERT
create policy "Only Admins can create order_hair" on public.order_hair
for insert
with check (
    authorize('Admin', auth.uid())
);

-- Policy for UPDATE
create policy "Only Admins can update order_hair" on public.order_hair
for update
using (
    authorize('Admin', auth.uid())
);

-- Create a function to prevent updates to product_id
CREATE OR REPLACE FUNCTION prevent_product_id_change()
RETURNS TRIGGER AS $$
BEGIN
  IF OLD.product_id IS DISTINCT FROM NEW.product_id THEN
    RAISE EXCEPTION 'product_id cannot be changed once set';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach the trigger function to the table for UPDATE
CREATE TRIGGER prevent_product_id_change_trigger
BEFORE UPDATE ON public.order_products
FOR EACH ROW
EXECUTE FUNCTION prevent_product_id_change();

-- Create a function to prevent updates to hair_id
CREATE OR REPLACE FUNCTION prevent_hair_id_change()
RETURNS TRIGGER AS $$
BEGIN
  IF OLD.hair_id IS DISTINCT FROM NEW.hair_id THEN
    RAISE EXCEPTION 'hair_id cannot be changed once set';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach the trigger function to the table for UPDATE
CREATE TRIGGER prevent_hair_id_change_trigger
BEFORE UPDATE ON public.order_hair
FOR EACH ROW
EXECUTE FUNCTION prevent_hair_id_change();

-- Create an AFTER INSERT trigger for order_products table
CREATE OR REPLACE FUNCTION update_product_units_in_stock_on_insert()
RETURNS TRIGGER AS $$
BEGIN
  IF (SELECT order_type FROM public.orders WHERE id = NEW.order_id) = 'purchase' THEN
    -- Calculate the new units_in_stock value for the product for a purchase order
    UPDATE public.products
    SET units_in_stock = units_in_stock + NEW.quantity
    WHERE id = NEW.product_id;
  ELSIF (SELECT order_type FROM public.orders WHERE id = NEW.order_id) = 'sale' THEN
    -- Calculate the new units_in_stock value for the product for a sale order
    UPDATE public.products
    SET units_in_stock = units_in_stock - NEW.quantity
    WHERE id = NEW.product_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach the trigger function to the table for INSERT
CREATE TRIGGER update_product_units_in_stock_trigger_on_insert
AFTER INSERT ON public.order_products
FOR EACH ROW
EXECUTE FUNCTION update_product_units_in_stock_on_insert();

-- Create an AFTER UPDATE trigger for order_products table
CREATE OR REPLACE FUNCTION update_product_units_in_stock_on_update()
RETURNS TRIGGER AS $$
DECLARE
  quantity_change integer;
BEGIN
  IF (SELECT order_type FROM public.orders WHERE id = NEW.order_id) = 'purchase' THEN
    -- Calculate the change in quantity for a purchase order
    quantity_change := NEW.quantity - OLD.quantity;

    -- Update the units_in_stock for the product for a purchase order
    UPDATE public.products
    SET units_in_stock = units_in_stock + quantity_change
    WHERE id = NEW.product_id;
  ELSIF (SELECT order_type FROM public.orders WHERE id = NEW.order_id) = 'sale' THEN
    -- Calculate the change in quantity for a sale order
    quantity_change := OLD.quantity - NEW.quantity;

    -- Update the units_in_stock for the product for a sale order
    UPDATE public.products
    SET units_in_stock = units_in_stock - quantity_change
    WHERE id = NEW.product_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- Attach the trigger function to the table for UPDATE
CREATE TRIGGER update_product_units_in_stock_trigger_on_update
AFTER UPDATE ON public.order_products
FOR EACH ROW
EXECUTE FUNCTION update_product_units_in_stock_on_update();

-- Create an AFTER DELETE trigger for order_products table
CREATE OR REPLACE FUNCTION update_product_units_in_stock_on_delete()
RETURNS TRIGGER AS $$
BEGIN
  IF (SELECT order_type FROM public.orders WHERE id = OLD.order_id) = 'purchase' THEN
    -- Update the units_in_stock for the product for a purchase order
    UPDATE public.products
    SET units_in_stock = units_in_stock - OLD.quantity
    WHERE id = OLD.product_id;
  ELSIF (SELECT order_type FROM public.orders WHERE id = OLD.order_id) = 'sale' THEN
    -- Update the units_in_stock for the product for a sale order
    UPDATE public.products
    SET units_in_stock = units_in_stock + OLD.quantity
    WHERE id = OLD.product_id;
  END IF;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- Attach the trigger function to the table for DELETE
CREATE TRIGGER update_product_units_in_stock_trigger_on_delete
AFTER DELETE ON public.order_products
FOR EACH ROW
EXECUTE FUNCTION update_product_units_in_stock_on_delete();
