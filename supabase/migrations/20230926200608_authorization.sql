-- Custom types for permissions
create type public.app_permission as enum ('contacts.create', 'contacts.update', 'contacts.delete');
create type public.app_role as enum ('admin', 'moderator', 'user');

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);

-- USER ROLES (many-to-many relationship between users and roles)
create table public.user_roles (
  user_id uuid references public.profiles(id),
  role app_role not null,
  primary key (user_id, role)
);

-- Grant all permissions to the admin role
insert into public.role_permissions (role, permission)
values
    ('admin', 'contacts.create'),
    ('admin', 'contacts.update'),
    ('admin', 'contacts.delete');

-- Function for role-based authorization
create function public.authorize(
  requested_permission app_permission,
  user_id uuid
)
returns boolean as $$
declare
  bind_permissions int;
begin
  select count(*)
  from public.role_permissions
  join public.user_roles on role_permissions.role = user_roles.role
  where role_permissions.permission = authorize.requested_permission
    and user_roles.user_id = authorize.user_id
  into bind_permissions;
  
  return bind_permissions > 0;
end;
$$ language plpgsql security definer;

-- Extend Policies for Contacts with Roles and Authorization
create policy "Allow authorized create access" on public.contacts for insert with check ( authorize('contacts.create', auth.uid()) );
create policy "Allow authorized update access" on public.contacts for update using ( authorize('contacts.update', auth.uid()) );
create policy "Allow authorized delete access" on public.contacts for delete using ( authorize('contacts.delete', auth.uid()) );
